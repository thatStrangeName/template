/**
 * robot.cpp
 *
 * In this file, set the global variables from robot.h
 *
 */

// at the top of a cpp file always include the necessary header files
#include "z839/robot.h"

//// include okapi's library. see documentation here: https://okapilib.github.io/OkapiLib/index.html
//#include "okapi/api.hpp"

// using namespace makes it so that you don't have to type okapi::Motor all the time instead you can just type Motor: https://docs.microsoft.com/en-us/cpp/cpp/namespaces-cpp?view=msvc-160
using namespace okapi; // all okapi classes, enums, etc
using namespace okapi::literals; // allows you to use
using namespace std;


/** Robot Sub Systems (intake, lift, etc) **/
shared_ptr<Motor> lift = make_shared<Motor>(
        /** motor port 1-20 (don't use port 21 because it has less power) **/
        11,

        /** true for negative (counterclockwise), false for positive (clockwise) **/
        false,

        /**
         *  motor gearset can be any of these:
         *       AbstractMotor::gearset::red (100 rpm)
         *       AbstractMotor::gearset::green (200 rpm)
         *       AbstractMotor::gearset::blue (600 rpm)
         */
        AbstractMotor::gearset::red,

        /**
         *  encoder units can be any of the following (almost always use count encoderUnits):
         *       AbstractMotor::encoderUnits::degrees (360 degrees per rotation)
         *       AbstractMotor::encoderUnits::rotations (1 rotation for 360 degrees)
         *       AbstractMotor::encoderUnits::counts (counts are based on the gearset)
         *           red gearset: 1800 counts per rotation
         *           green gearset: 900 counts per rotation
         *           blue gearset: 300 counts per rotation
         *
         *           Note: encoders are 360 counts per rotation
         */
        AbstractMotor::encoderUnits::counts
);

MotorGroup intake(
        /** motor port list from 1-20 (negative ports are ports moving negative or counterclockwise) **/
        {16, -17, 18, -19}

        /**
         * The default gearset is AbstractMotor::gearset::green (200 rpm)
         *
         * The default encoderUnits is AbstractMotor::encoderUnits::counts (counts are based on the gearset)
         *
         * Change the gearset by calling the setGearing method here: https://okapilib.github.io/OkapiLib/classokapi_1_1MotorGroup.html#a5720f3775594f0097856754776526a47
         * For example:
         *      intake.setGearing(AbstractMotor::gearset::blue);
         *
         * Note: This example will also work on the lift variable (this is because both Motor and MotorGroup inherit the AbstractMotor class see: https://docs.microsoft.com/en-us/cpp/cpp/single-inheritance?view=msvc-160)
         */
);

/**
 * You can set these variables on any motor:
 *      max voltage (max voltage is 12000 milliVolts)
 *
 *          intake.setVoltageLimit(9000);
 *
 *      max current (default max current is 2500 milliAmps)
 *
 *          intake.setCurrentLimit(800);
 *
 *      brake mode (break modes are how the motor reacts when the motor is set to 0):
 *          AbstractMotor::brakeMode::coast (Motor coasts when stopped, traditional behavior)
 *          AbstractMotor::brakeMode::brake (Motor brakes when stopped)
 *          AbstractMotor::brakeMode::hold (Motor actively holds position when stopped)
 *
 *          intake.setBrakeMode(AbstractMotor::brakeMode::hold);
 *
 *      Note: default brake mode is AbstractMotor::brakeMode::coast
 *
 * You can get these variables on any motor:
 *      get actual rotational velocity (in rotations per minute)
 *
 *      Gets the torque generated by the motor in Newton Metres (Nm).
 *
 *          double intakeTorque = intake.getTorque();
 *          std::cout << "intakeTorque is " << intakeTorque << "\n";
 *
 *      Gets the temperature of the motor in degrees Celsius.
 *
 *          double intakeTemperature = intake.getTemperature();
 *          std::cout << "intakeTemperature is " << intakeTemperature << "\n";
 *
 *      Gets the voltage delivered to the motor in millivolts.
 *
 *          double intakeVoltage = intake.getVoltage();
 *          std::cout << "intakeVoltage is " << intakeVoltage << "\n";
 *
 * Note: This doesn't include all motor methods (only the most common ones) see this for all methods:
 *      Motor methods: https://okapilib.github.io/OkapiLib/classokapi_1_1Motor.html
 *      MotorGroup methods: https://okapilib.github.io/OkapiLib/classokapi_1_1MotorGroup.html
 */

/** Robot drive **/
// We're using a ChassisControllerBuilder to make a ChassisController see: https://okapilib.github.io/OkapiLib/md_docs_tutorials_walkthrough_chassisControllerBuilder.html
shared_ptr<ChassisController> drive = ChassisControllerBuilder()
        .withMotors(
                {1, -10}, // Left motors are 1 & 2 (reversed)
                {-20, 11}    // Right motors are 3 & 4
        )
        /**
         * This will set the dimensions of the drive. This is the most important part of your code, because
         * these numbers are going to be the difference between barely working auto and a winning one.
         */
        .withSensors(
                ADIEncoder{'A','B'},
                ADIEncoder{'C','D',true}
        )
        .withDimensions(
                /**
                 * First variable will set the gearset of all the motors in the drive.
                 *
                 * Second variable is the gear ratio for the drive gears the formula for this is:
                 *      drive shaft gear's tooth count / output shaft gear's tooth count
                 *
                 *      for example: if you had a drive with 600rpm motors with 36 teeth on the motor shaft,
                 *      and 60 teeth on the output shaft, then you would put replace the line below with this:
                 *
                 *      {AbstractMotor::gearset::blue, (36.0 / 60.0))},
                 *
                 *  Note: If you get the gear ratio wrong, then if you tell the robot to drive forward 1 foot,
                 *  it might drive 2 inches or 5 feet depending on how you got the math wrong
                 */
                {AbstractMotor::gearset::green, 1},

                /**
                 * First variable is a list of measurments.
                 *
                 * In okapi, there are shortcuts for measurements. By putting `_unit` after a number where unit,
                 * can any of the literal columns here: https://okapilib.github.io/OkapiLib/md_docs_api_units.html
                 *
                 * However, the units we need to put in here (only length units) can be the following:
                 *      _m for meter
                 *      _cm for centimeter
                 *      _mm for millimeter
                 *      _km for kilometer (not sure why this is in here, but ¯\_(ツ)_/¯)
                 *      _in for inch
                 *      _ft for foot
                 *      _yd for yard
                 *      _mi for mile (not sure why this is in here, but ¯\_(ツ)_/¯)
                 */
                {
                       {
                           /**
                            * This is the single most important variable for an autonomous routine, because every other
                            * system, or variable depends on it.
                            *
                            * This variable is the diameter of the drive wheels.
                            *
                            *                        Wheel diameter / Straight scale variable
                            *
                            *                         +-+
                            *                         | |
                            *                         v v
                            *                                  Center of rotation
                            *                         ===      |      ===
                            *                          +       |       +
                            *                         ++---------------++
                            *                         |                 |
                            *                         |                 |
                            *                         |        x        |
                            *                         |                 |
                            *                         |                 |
                            *                         ++---------------++
                            *                          +               +
                            *                         ===             ===
                            *
                            * How to tune the straight scale variable:
                            *       1. Put in your best guess of your wheel's diameter
                            *           (i.e. if you have a 3.25 inch wheel, set this variable to about: 3.25_in)
                            *       2. Put your robot on tiles, and have a program similair to this in your
                            *           autonomous method:
                            *
                            *           // before you start, mark where the is:
                            *           //     with a piece of tape
                            *           //     by placing the robot against a field's wall
                            *           //     putting the back of the robot between the seams of two tiles
                            *           //     or whatever you come up with you get the idea
                            *           //
                            *           // also mark where you want the robot to go with the same methods above
                            *
                            *           // tell the robot to move a specific distance (i.e. 48 inches or 2 tiles)
                            *           drive->moveDistance(48_in);
                            *
                            *           // wait to let the robot settle, and to determine whether you need to increase or decrease your straight scale variable
                            *           pros::delay(2000);
                            *
                            *           // tell the robot to move back the same distance you told it to move forward
                            *           drive->moveDistance(-48_in);
                            *
                            *           // When the robot moves forward accurately enough for your taste,
                            *               then you can tune the turning scales variable in the next section
                            *
                            */
                           3.25_in,

                           /**
                            * This is the second most important variable for an autonomous routine, because turning
                            * 89 instead of 90 degrees can be the difference between a successful auton and a
                            * failed auton.
                            *
                            * This variable is the distance between the center of mass of the robot and the wheels.
                            * It is called the turn scale variable.
                            *
                            *                                       Center of mass
                            *                                       |
                            *                                       |
                            *                                       |
                            *                     +--->    ===      |      ===
                            *                     |         +       v       +
                            *                     |        ++---------------++
                            *                     |        |                 |
                            *        Turn Scale   |        |                 |
                            *                     |        |        x        |
                            *                     |        |                 |
                            *                     |        |                 |
                            *                     |        ++---------------++
                            *                     |         +               +
                            *                     +--->    ===             ===
                            *
                            * How to tune the turn scale variable:
                            *       1. Before you tune the turn scale variable, make sure that you have your straight
                            *           scale variable as good as you're going to get it because this variable is dependant
                            *           on the straight scale variable.
                            *       2. Put in your best guess for the width between your two wheels
                            *       3. Put your robot on tiles, and have a program similair to this in your
                            *           autonomous method:
                            *
                            *           // before you start, mark the angle of the robot:
                            *           //     with a piece of tape
                            *           //     putting the back of the robot between the seams of two tiles
                            *           //     or whatever you come up with you get the idea
                            *
                            *           // reset the encoders to 0
                            *           drive->getModel()->resetSensors();
                            *
                            *           // log one of the encoder's sides
                            *           double startEncoderValue = drive->getModel()->getLeftSideMotor()->getEncoder()->get();
                            *           std::cout << "startEncoderValue is " << startEncoderValue << "\n";
                            *
                            *           // tell the robot to turn 5 times (i.e. 1800)
                            *           drive->turnAngle(1800_deg);
                            *
                            *           // wait to let the robot settle, and to determine whether you need to increase or decrease your straight scale variable
                            *           pros::delay(2000);
                            *
                            *           // log one of the encoder's sides
                            *           double middleEncoderValue = drive->getModel()->getLeftSideMotor()->getEncoder()->get();
                            *           std::cout << "middleEncoderValue is " << middleEncoderValue << "\n";
                            *
                            *           // tell the robot to move back the same distance you told it to move forward
                            *           drive->turnAngle(-1800_deg);
                            *
                            *           // wait to let the robot settle
                            *           pros::delay(500);
                            *
                            *           // log one of the encoder's sides
                            *           double lastEncoderValue = drive->getModel()->getLeftSideMotor()->getEncoder()->get();
                            *           std::cout << "lastEncoderValue is " << lastEncoderValue << "\n";
                            *
                            *           // When the robot moves turns accurately enough for your taste,
                            *               then it's time to write an autonomous
                            *
                            */
                           12_in
                       },

                /**
                 * Depending on what gearset you have will change what you set this variable as:
                 *      red gearset set to: imev5RedTPR
                 *      green gearset set to: imev5GreenTPR
                 *      blue gearset set to: imev5BlueTPR
                 *
                 *      Note: If you're using an encoder set to: quadEncoderTPR
                 */     
                    imev5GreenTPR
                }
        ).build();



/** Controller **/
shared_ptr<Controller> master = make_shared<Controller>();
ControllerButton a(ControllerDigital::A);
// TODO: Uncomment the buttons below and initialize them see: https://okapilib.github.io/OkapiLib/classokapi_1_1ControllerButton.html
ControllerButton b(ControllerDigital::B);
ControllerButton x(ControllerDigital::X);
ControllerButton y(ControllerDigital::Y);
ControllerButton r1(ControllerDigital::R1);
ControllerButton r2(ControllerDigital::R2);
ControllerButton l1(ControllerDigital::L1);
ControllerButton l2(ControllerDigital::L2);
ControllerButton up(ControllerDigital::up);
ControllerButton down(ControllerDigital::down);
ControllerButton left(ControllerDigital::left);
ControllerButton right(ControllerDigital::right);

/** Cool Stuff **/
const double displayQLengthRatio = (1*inch).getValue();
double displayQLength(QLength length) { return length.getValue()/displayQLengthRatio; }

const double displayQAngleRatio = (1*degree).getValue();
double displayQAngle(QAngle angle) { return angle.getValue()/displayQAngleRatio; }
// position controller for the lift
//      world's best PID demo in existence https://www.youtube.com/watch?v=fusr9eTceEo
//      how to program page 13-14: https://github.com/team914/autolib-pdfs/blob/master/pid-controllers.pdf
//      how to program page 1-12: https://github.com/team914/autolib-pdfs/blob/master/pid-controllers.pdf
// TODO: initialize the liftController so that it's usable see: https://okapilib.github.io/OkapiLib/md_docs_tutorials_walkthrough_liftMovement.html
shared_ptr<AsyncPosPIDController> liftController;